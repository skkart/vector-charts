{"version":3,"sources":["webpack://vc/./data-parser/BasicBSParser.js","webpack://vc/./series/Bar.js","webpack://vc/./series/BarSeries.js","webpack://vc/./charts/BarSeriesChart.js","webpack://vc/./tooltip/BasicTooltip.js"],"names":["BasicBSParser","opts","this","dataOptions","data","series","yAxis","constructChartData","constructXAxisInfo","constructPlotInfo","constructYAxisInfo","err","console","log","onError","Error","seriesData","barseries","columns","values","length","chartData","timeInfo","dataIndex","timeRange","map","dt","eachPlotSet","plotSet","plotInfo","getObject","yAxis2","key","yRange","yRange2","min","max","findEachPlotRange","minVal","maxVal","valData","forEach","d","plot","eachPlot","bar","plotData","barType","constants","STACKED_BAR","memberArr","barOrderMembers","sum","member","name","visible","valueRange","allMax","Infinity","allMax2","BAR_KEY","GROUPED_BAR","plotAxis","DIR_LEFT","DIR_RIGHT","allMin","allMin2","yMin","yMax","reduce","a","b","slice","ind","dataColorArr","color","yLeft","yRight","refineName","refineString","unit","isBoolean","ChartAxisParser","Bar","className","DIR_BOTTOM","barData","xAxisTarget","events","self","chart","options","barOrderIndex","filter","ele","seriesLength","x","indexOf","DIR_TOP","y","xScale","yScale","srData","seriesArr","xAxisArr","sData","push","indexVal","brInd","barStack","stack","keys","range","transpose","yMaxGrouped","yMaxStacked","nameIndexMap","pt","clipElement","container","select","barSeries","graphZone","selectAll","enter","append","attr","i","bars","srName","parentNode","colorArr","chartHeight","bandwidth","on","tooltip","hover","d3Event","pageX","pageY","val","hide","fn","apply","arguments","showFlag","classed","remove","draw","ChartComponent","BarSeries","plotSeries","isBarPlot","isArray","isStackPlot","arrayData","stackOrderMembers","Series","BarSeriesChart","startTime","Date","dataParser","addDefaultBSOptions","isObject","dataExecutor","chartInitilize","axisOptions","Axis","position","orient","rangeScale","domainScale","chartComponentsArr","xAxis","chartWidth","tooltipOpts","Tooltip","legend","legends","TimeSeriesLegend","legendPrefix","disableSeriesToggle","onLegendChange","afterDraw","call","reScaleYAxis","chartResponsive","mouseHandler","triggerMouseAction","timeDiff","getTime","onComplete","axisSpecifier","tickValArr","diffVal","rangeVal","applyY1Axis","applyY2Axis","tickValues","modifyAxisProps","reScaleAxis","requiredWidth","class","maxText","dummyG","svg","axis","each","tickHtml","text","String","getComputedTextLength","margin","Math","round","Y_AXIS_SPACE","chartFullSpace","width","left","right","update","Chart","BasicTooltip","isFunction","format","toolTipDiv","displayData","excludeToolTipDiv","showHide","box","elementOffset","rootPos","xpos","ypos","top","height","style","html","$toolTipDiv"],"mappings":"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","file":"barseries.min.js","sourcesContent":["import ChartAxisParser from '@/data-parser/ChartAxisParser'\nimport {getObject, refineString, isBoolean} from '@/utils'\nimport constants from '@/constants'\n\n\nexport default class BasicBSParser extends ChartAxisParser {\n  constructor (opts) {\n    super(opts)\n    this.opts = opts\n  }\n\n  dataExecutor () {\n    // Order in which the DataProcessor APIs needs to be executed\n    try {\n\n      this.dataOptions = {}\n      this.opts.data && (this.dataOptions.data = this.opts.data)\n      this.opts.series && (this.dataOptions.series = this.opts.series)\n      this.opts.yAxis && (this.dataOptions.yAxis = this.opts.yAxis)\n\n      Object.assign(this.dataOptions, this.constructChartData())\n      Object.assign(this.dataOptions, this.constructXAxisInfo())\n      Object.assign(this.dataOptions, this.constructPlotInfo())\n      Object.assign(this.dataOptions, this.constructYAxisInfo())\n\n      return this.dataOptions\n\n    } catch (err) {\n      console.log('Error encountered while bar series JSON parsing :', err)\n      this.opts.onError(err)\n      throw new Error('Invalid JSON received - Error on bar series JSON parsing')\n    }\n  }\n\n  constructChartData () {\n    const dataOptions = this.dataOptions\n    const resJson = dataOptions.data\n    const seriesData = resJson.barseries\n    const columns = seriesData.columns\n    const data = seriesData.values\n    const validJSONType = (columns.length && data.length)\n\n    if (!validJSONType) {\n      throw new Error('Invalid Bar series JSON received')\n    }\n\n    return {\n      chartData: data\n    }\n  }\n\n  constructXAxisInfo () {\n    const dataOptions = this.dataOptions\n    const seriesData = dataOptions.chartData\n    const dataIndex = 0\n    return {\n      timeInfo: {\n        dataIndex,\n        timeRange: seriesData.map((dt) => dt[0])\n      }\n    }\n  }\n\n  constructYAxisInfo () {\n    const dataOptions = this.dataOptions\n    const eachPlotSet = dataOptions.plotSet\n    const plotInfo = dataOptions.series\n    const data = dataOptions.chartData\n    const yAxis = getObject(dataOptions, 'yAxis.left')\n    const yAxis2 = getObject(dataOptions, 'yAxis.right')\n    let key\n    let yRange = null\n    let yRange2 = null\n\n\n    if (yAxis) {\n      if (Number.isFinite(yAxis.min) && Number.isFinite(yAxis.max)) {\n        yRange = [yAxis.min, yAxis.max]\n      }\n    }\n\n    if (yAxis2) {\n      if (Number.isFinite(yAxis2.min) && Number.isFinite(yAxis2.max)) {\n        yRange2 = [yAxis2.min, yAxis2.max]\n      }\n    }\n\n    // If yRange is not set from graphOptions, then go inside\n    if (!yRange || !yRange2) {\n      let findEachPlotRange = false\n      for (key in eachPlotSet) {\n        if (!Number.isFinite(eachPlotSet[key].minVal) || !Number.isFinite(eachPlotSet[key].maxVal)) {\n          findEachPlotRange = true\n          break\n        }\n      }\n\n      if (findEachPlotRange) {\n\n        // Calculate Max and Min for each plots series\n        let valData = 0\n        data.forEach(function (d) {\n          for (const plot in eachPlotSet) {\n            const eachPlot = eachPlotSet[plot]\n            valData = d[eachPlot.dataIndex]\n            if (valData < eachPlot.minVal) {\n              eachPlot.minVal = valData\n            }\n            if (valData > eachPlot.maxVal) {\n              eachPlot.maxVal = valData\n            }\n            // Attach value range for stacked bar data\n            plotInfo.bar && plotInfo.bar.forEach(function (plotData) {\n              if (plotData.barType === constants.STACKED_BAR) {\n                const memberArr = plotData.barOrderMembers\n                let sum = 0\n                // Calculate maximum and minimum range for stacked group by adding all the data\n                memberArr.forEach(function (member) {\n                  sum += (eachPlotSet[member.name].visible ? d[eachPlotSet[member.name].dataIndex] : 0)\n                })\n\n                if (sum < plotData.valueRange[0]) {\n                  plotData.valueRange[0] = sum\n                }\n                if (sum > plotData.valueRange[1]) {\n                  plotData.valueRange[1] = sum\n                }\n              }\n\n            })\n          }\n        })\n      }\n\n      // Find Max value required to plot on graph based on visible plot function . i.e line or stack\n      let allMax = -Infinity\n      let allMax2 = -Infinity\n      for (key in plotInfo) {\n        if (key === constants.BAR_KEY) {\n          plotInfo[key].forEach(function (plotData) {\n            // calculate maximum and minimum range if bar type is a grouped bar\n            if (plotData.barType === constants.GROUPED_BAR) {\n              const memberArr = plotData.barOrderMembers\n              memberArr.forEach(function (member) {\n                if (eachPlotSet[member.name].visible && eachPlotSet[member.name].plotAxis[0] === constants.DIR_LEFT && eachPlotSet[member.name].maxVal > allMax) {\n                  allMax = eachPlotSet[member.name].maxVal\n                }\n                if (eachPlotSet[member.name].visible && eachPlotSet[member.name].plotAxis[0] === constants.DIR_RIGHT && eachPlotSet[member.name].maxVal > allMax2) {\n                  allMax2 = eachPlotSet[member.name].maxVal\n                }\n              })\n            } else if (plotData.barType === constants.STACKED_BAR) {\n              if (plotData.plotAxis[0] === constants.DIR_LEFT && plotData.valueRange[1] > allMax) {\n                allMax = plotData.valueRange[1]\n              }\n              if (plotData.plotAxis[0] === constants.DIR_RIGHT && plotData.valueRange[1] > allMax2) {\n                allMax2 = plotData.valueRange[1]\n              }\n\n            }\n\n          })\n        }\n      }\n\n      // Find min value just by checking min value among all series data\n      let allMin = Infinity\n      let allMin2 = Infinity\n      for (key in eachPlotSet) {\n        if (eachPlotSet[key].plotAxis && eachPlotSet[key].plotAxis[0] === 'left' && eachPlotSet[key].visible && eachPlotSet[key].minVal < allMin) {\n          allMin = eachPlotSet[key].minVal\n        }\n        if (eachPlotSet[key].plotAxis && eachPlotSet[key].plotAxis[0] === 'right' && eachPlotSet[key].visible && eachPlotSet[key].minVal < allMin2) {\n          allMin2 = eachPlotSet[key].minVal\n        }\n      }\n\n\n      let yMin, yMax\n      // If Yaxis range is already defined in options, Override it.\n      if ([allMin, allMax].reduce(function (a, b) {\n        return Number.isFinite(a) && Number.isFinite(b)\n      })) {\n        yMin = getObject(dataOptions, 'yAxis.left.min')\n        yMin = Number.isFinite(yMin) ? yMin : allMin\n        yMax = getObject(dataOptions, 'yAxis.left.max')\n        yMax = Number.isFinite(yMax) ? yMax : allMax\n        if (!yMax) {\n          yMax = yMin + 80 // Set as default 100 if range is [0,0]\n        }\n        yRange = [yMin, yMax]\n      } else {\n        if (yAxis) {\n          yRange = [0, 80]\n        } else {\n          yRange = false\n        }\n      }\n\n\n      if ([allMin2, allMax2].reduce(function (a, b) {\n        return Number.isFinite(a) && Number.isFinite(b)\n      })) {\n        yMin = getObject(dataOptions, 'yAxis.right.min')\n        yMin = Number.isFinite(yMin) ? yMin : allMin2\n        yMax = getObject(dataOptions, 'yAxis.right.max')\n        yMax = Number.isFinite(yMax) ? yMax : allMax2\n        if (!yMax) {\n          yMax = yMin + 80 // Set as default 100 if range is [0,0]\n        }\n        yRange2 = [yMin, yMax]\n      } else {\n        if (yAxis2) {\n          yRange2 = [0, 80]\n        } else {\n          yRange2 = false\n        }\n      }\n\n    }\n\n    return {\n      yRange: yRange,\n      yRange2: yRange2\n    }\n  }\n\n  constructPlotInfo () {\n    const dataOptions = this.dataOptions\n    const resJson = dataOptions.data\n    const seriesData = resJson.barseries\n    const columns = seriesData.columns.slice(1) // Ignore the first column, As it corresponds to x axis\n    let ind = 1\n    // Object that contains all plot functions needed for the chart\n    const eachPlotSet = {}\n    // Set of rules that charts needs to be draw on timeSeriesChart\n    const plotInfo = dataOptions.series\n    let key\n\n    const dataColorArr = seriesData.color || []\n    const yLeft = getObject(dataOptions, 'yAxis.left')\n    const yRight = getObject(dataOptions, 'yAxis.right')\n\n    // Generate eachPlotSet using columns\n    columns.forEach(function (d) {\n      // Convert the Series Name to JS suitable object mapped name ex: abc(%) 1 --> abc1\n      const refineName = refineString(d)\n      eachPlotSet[refineName] = {\n        name: d,\n        dataIndex: ind,\n        minVal: Infinity,\n        maxVal: -Infinity,\n        visible: true,\n        color: dataColorArr[ind] || '#000'\n      }\n      ind++\n    })\n\n\n    for (key in plotInfo) {\n      if (key === 'bar') {\n        plotInfo[key].forEach(function (plotData) {\n          const memberArr = plotData.barOrderMembers\n          plotData.valueRange = [Infinity, -Infinity]\n          memberArr.forEach(function (member) {\n            member.name = refineString(member.name)\n            const color = member.color // Apply color for each Plot series or pick from data color Arr\n            if (!color) {\n              throw `Color not present for series ${plotData.name}`\n            }\n            color && (eachPlotSet[member.name].color = color)\n            const plotAxis = member.plotAxis || ['left', 'bottom']\n            eachPlotSet[member.name].plotAxis = plotAxis\n            const unit = plotAxis[0] === 'left' ? yLeft.unit : yRight.unit\n            eachPlotSet[member.name].unit = unit\n            isBoolean(member.visible) && (eachPlotSet[member.name].visible = member.visible)\n          })\n        })\n      }\n    }\n\n    return {\n      series: plotInfo, // newly updated series from user options having additional info of each series\n      plotSet: eachPlotSet, // Info of each plot like color, max, min etc\n    }\n  }\n}\n","import ChartComponent from '@/charts/ChartComponent'\nimport constants from '@/constants'\nimport {getObject} from '@/utils'\nimport {stack, range, transpose, max, select, d3Event} from '@/d3Importer'\n\nexport default class Bar extends ChartComponent {\n  constructor (opts) {\n    super()\n\n    this.opts = Object.assign({\n      className: '',\n      plotAxis: [constants.DIR_LEFT, constants.DIR_BOTTOM],\n      barData: null,\n      xAxisTarget: null,\n      barType: constants.GROUPED_BAR,\n      barOrderMembers: {},\n      visible: true,\n      events: {}\n    }, opts)\n\n    const self = this\n\n    const eachPlotSet = this.opts.chart.options.plotSet\n    this.opts.barOrderIndex = this.opts.barOrderMembers.filter(function (ele) {\n      return eachPlotSet[ele.name].visible || false\n    })\n      .map(function (ele) {\n        return eachPlotSet[ele.name].dataIndex\n      })\n\n    this.opts.seriesLength = this.opts.barOrderIndex.length\n    // Find x and y axis based on plotAxis\n    let x = getObject(this.opts, 'chart.xAxis.scale')\n    if (this.opts.plotAxis.indexOf(constants.DIR_TOP) > -1) {\n      x = getObject(this.opts, 'chart.xAxis2.scale')\n    }\n\n    let y = getObject(this.opts, 'chart.yAxis.scale')\n    if (this.opts.plotAxis.indexOf(constants.DIR_RIGHT) > -1) {\n      y = getObject(this.opts, 'chart.yAxis2.scale')\n    }\n\n    this.xScale = x\n    this.yScale = y\n\n    const srData = this.opts.barData\n    this.opts.seriesArr = []\n    this.opts.xAxisArr = []\n    srData.forEach((sData, ind) => {\n      this.opts.xAxisArr.push(sData[this.opts.xAxisTarget])\n      this.opts.barOrderIndex.forEach(function (indexVal, brInd) {\n        if (!self.opts.seriesArr[brInd]) {\n          self.opts.seriesArr[brInd] = []\n        }\n        const eachSeriesData = self.opts.seriesArr[brInd]\n        eachSeriesData.push(sData[indexVal])\n      })\n    })\n    // this.opts.barOrderIndex.forEach(function (indexVal) {\n    //   self.opts.seriesArr.push(map(srData, indexVal))\n    // })\n\n    this.opts.barStack = stack().keys(range(this.opts.seriesLength))(transpose(this.opts.seriesArr))\n\n    this.yMaxGrouped = max(this.opts.seriesArr, function (y) {\n      return max(y)\n    })\n    this.yMaxStacked = max(this.opts.barStack, function (y) {\n      return max(y, function (d) {\n        return d[1]\n      })\n    })\n  }\n\n  draw () {\n    const self = this\n    const nameIndexMap = {}\n    const eachPlotSet = this.opts.chart.options.plotSet\n    const barVisibleOrder = this.opts.barOrderMembers.filter(function (ele) {\n      return (eachPlotSet[ele.name].visible || false)\n    })\n    barVisibleOrder.forEach(function (plot, name) {\n      const pt = eachPlotSet[plot.name]\n      nameIndexMap[pt.dataIndex - 1] = plot.name\n    })\n\n\n    const clipElement = this.opts.chart.container.select('svg clipPath')\n    this.barSeries = this.opts.chart.graphZone.selectAll('.vc-bar-series')\n      .data(this.opts.barStack)\n      .enter()\n      .append('g')\n      .attr('clip-path', 'url(#' + clipElement.attr('id') + ')') // display graphZone of same size as clip-path defined\n      .attr('class', 'vc-bar-series')\n      .attr('fill', function (d, i) {\n        return eachPlotSet[nameIndexMap[i]].color\n      })\n      .attr('seriesName', function (d, i) {\n        return nameIndexMap[i]\n      })\n      .attr('seriesIndex', function (d, i) {\n        return i\n      })\n\n\n    this.bars = this.barSeries.selectAll('rect')\n      .data(function (d) {\n        return d\n      })\n      .enter().append('rect')\n      .attr('x', function (d, i) {\n        return self.xScale(self.opts.xAxisArr[i])\n      })\n      .attr('fill', function (d, i) {\n        const srName = select(this.parentNode).attr('seriesName')\n        return eachPlotSet[srName].colorArr && eachPlotSet[srName].colorArr[i]\n      })\n      .attr('y', this.opts.chart.chartHeight)\n      .attr('width', this.xScale.bandwidth())\n      .attr('height', 0)\n      .on('mousemove', function (d, i) {\n        self.opts.chart.tooltip && self.opts.chart.tooltip.hover(d3Event.pageX, d3Event.pageY, {\n          data: {\n            val: self.opts.barData[i],\n            ind: i\n          }\n        })\n      })\n      .on('mouseout', function (d) {\n        self.opts.chart.tooltip && self.opts.chart.tooltip.hide()\n      })\n\n    for (const name in this.opts.events) {\n      const fn = this.opts.events[name]\n      self.bars.on(name, function () {\n        fn.apply(self.opts.chart, arguments)\n      })\n    }\n\n  }\n\n  // Update happens when the chart is resized\n  update () {\n    const self = this\n    if (this.opts.barType === constants.STACKED_BAR) {\n      this.bars\n        .attr('y', function (d) {\n          return self.yScale(d[1])\n        })\n        .attr('height', function (d) {\n          return self.yScale(d[0]) - self.yScale(d[1])\n        })\n        .attr('x', function (d, i) {\n          return self.xScale(self.opts.xAxisArr[i])\n        })\n        .attr('width', self.xScale.bandwidth())\n    } else {\n      this.bars\n        .attr('x', function (d, i) {\n          const xVal = self.xScale(self.opts.xAxisArr[i]) + self.xScale.bandwidth() / self.opts.seriesLength * select(this.parentNode).attr('seriesIndex')\n          return xVal\n        })\n        .attr('width', self.xScale.bandwidth() / self.opts.seriesLength)\n        .attr('y', function (d) {\n          return self.yScale(d[1] - d[0])\n        })\n        .attr('height', function (d) {\n          return self.yScale(0) - self.yScale(d[1] - d[0])\n        })\n    }\n  }\n\n  showHide (showFlag) {\n    showFlag = !!showFlag\n    this.barSeries.classed('vc-hidden', !showFlag)\n    this.opts.visible = showFlag\n  }\n\n  // Redraw is called when series is toggled from Legends\n  redraw () {\n    const eachPlotSet = this.opts.chart.options.plotSet\n    // Modify barOrder arr based on visibleSeries\n    this.opts.barOrderIndex = this.opts.barOrderMembers.filter(function (ele) {\n      return (eachPlotSet[ele.name].visible || false)\n    })\n      .map(function (ele) {\n        return eachPlotSet[ele.name].dataIndex\n      })\n\n    // Remove all bar series\n    this.barSeries && this.barSeries.remove()\n    // draw with new barOrderMembers\n    this.draw()\n  }\n\n  remove () {\n    this.barSeries && this.barSeries.remove()\n    this.bars = null\n    this.opts = null\n  }\n\n}\n","import {isArray} from '@/utils'\nimport Bar from '@/series/Bar'\nimport Series from '@/series/Series'\n\nexport default class BarSeries extends Series {\n  constructor (opts) {\n    super()\n    this.opts = opts\n    this.plotSeries = []\n    const data = this.opts.chart.options.chartData // Accept either timeseries or pieseries\n    const plotInfo = this.opts.chart.options.series\n    const isBarPlot = isArray(plotInfo.bar) && plotInfo.bar.length\n    const isStackPlot = isArray(plotInfo.stack) && plotInfo.stack.length\n    let arrayData = []\n\n    // check which data needs to be passed and present\n    if (isBarPlot) {\n      arrayData = plotInfo.bar\n    } else if (isStackPlot) {\n      arrayData = plotInfo.stack\n    }\n\n    // Create plot components based on input options and each plot info\n    arrayData.forEach((plotData) => {\n      this.plotSeries.push(new Bar({\n        chart: this.opts.chart,\n        className: plotData.className || plotData.name,\n        plotAxis: plotData.plotAxis,\n        xAxisTarget: this.opts.chart.options.timeInfo.dataIndex,\n        barOrderMembers: plotData.barOrderMembers || plotData.stackOrderMembers,\n        barType: plotData.barType || '',\n        events: plotData.events || {},\n        barData: data\n      }))\n    })\n  }\n\n}\n","import {getObject, isObject} from '@/utils'\nimport Chart from '@/charts/Chart'\nimport Axis from '@/axis'\nimport {addDefaultBSOptions} from '@/helpers'\nimport constants from '@/constants'\nimport ChartAxisParser from '@/data-parser/ChartAxisParser'\nimport Tooltip from '@/tooltip/BasicTooltip'\nimport BasicBSParser from '@/data-parser/BasicBSParser'\nimport BarSeries from '@/series/BarSeries'\nimport {select} from '@/d3Importer'\nimport TimeSeriesLegend from '@/legend/TimeSeriesLegend'\n\nexport default class BarSeriesChart extends Chart {\n  constructor (container, opts) {\n    opts.startTime = new Date()\n\n    // Create the dataParser is not passed\n    if (!opts.dataParser) {\n      opts.dataParser = new BasicBSParser(opts)\n    }\n    // Check the dataParser exists and its instanceof ChartAxisParser\n    if (!(opts.dataParser instanceof ChartAxisParser)) {\n      throw new Error(\"DataParser in options dosen't have implementation of ChartAxisParser\")\n    }\n\n    // Call Parent Impl\n    super(container, opts)\n\n    // Add default options to chart\n    addDefaultBSOptions(this.options)\n\n    // Run the dataParser for given JSON data\n    if (isObject(this.dataParser)) {\n      Object.assign(this.options, this.dataParser.dataExecutor())\n    }\n\n    // Initilize all chart components needed for timeSeriesChart on exact order based on each dependencies\n    this.chartInitilize()\n\n    setImmediate(() => this.draw())\n  }\n\n  chartInitilize () {\n    let axisOptions\n    const yRange = this.options.yRange\n    const yRange2 = this.options.yRange2\n    const timeInfo = this.options.timeInfo\n\n    if (yRange) {\n      axisOptions = getObject(this, 'options.yAxis.left')\n      this.yAxis = new Axis({\n        chart: this,\n        position: 'y',\n        orient: 'left',\n        rangeScale: [this.chartHeight, 0],\n        domainScale: yRange,\n        ...axisOptions\n      })\n      this.chartComponentsArr.push(this.yAxis)\n    }\n\n    if (yRange2) {\n      axisOptions = getObject(this, 'options.yAxis.right')\n      this.yAxis2 = new Axis({\n        chart: this,\n        position: 'y',\n        orient: 'right',\n        rangeScale: [this.chartHeight, 0],\n        domainScale: yRange2,\n        ...axisOptions\n      })\n      // Register the component for draw, update, showHide and remove (chart API)\n      this.chartComponentsArr.push(this.yAxis2)\n    }\n\n    if (timeInfo.timeRange) {\n      axisOptions = getObject(this, 'options.xAxis.bottom')\n      this.xAxis = new Axis({\n        chart: this,\n        position: 'x',\n        orient: 'bottom',\n        rangeScale: [0, this.chartWidth],\n        domainScale: timeInfo.timeRange,\n        ...axisOptions\n      })\n      this.chartComponentsArr.push(this.xAxis)\n    }\n\n    const tooltipOpts = getObject(this, 'options.tooltip')\n    if (tooltipOpts.visible) {\n      this.tooltip = new Tooltip({\n        chart: this,\n        ...tooltipOpts\n      })\n      this.chartComponentsArr.push(this.tooltip)\n    }\n\n    if (this.options.series) {\n      this.series = new BarSeries({\n        chart: this\n      })\n      // Register the component for draw, update, showHide and remove\n      this.chartComponentsArr.push(this.series)\n    }\n\n    if (this.options.legend && this.options.legend.visible) {\n      this.legends = new TimeSeriesLegend({\n        chart: this,\n        legendPrefix: this.options.legend.legendPrefix,\n        position: constants.DIR_TOP,\n        disableSeriesToggle: true, // Disable series toggle effect for bar graph. TODO: Need to support toggling of series\n        onLegendChange: this.options.legend.onLegendChange\n      })\n\n      this.chartComponentsArr.push(this.legends)\n    }\n\n\n  }\n\n  draw () {\n    console.log('BarSeriesChart draw', this)\n    super.draw()\n    this.options.afterDraw.call(this)\n\n    // Add Extra Buffer for max Y value and provide space to display all ticks in graphZone\n    this.reScaleYAxis()\n\n    this.chartResponsive()\n\n    this.mouseHandler && this.mouseHandler.triggerMouseAction()\n\n    this.timeDiff = (new Date()\n      .getTime() - this.options.startTime.getTime())\n    this.options.onComplete.call(this, this.timeDiff)\n  }\n\n  // Find next possible tick to display max Y value and adjust margin to show all tick labels completely\n  reScaleYAxis (axisSpecifier) {\n\n    let tickValArr\n    let diffVal\n    let rangeVal\n    let yMax\n    let applyY1Axis = true\n    let applyY2Axis = true\n\n    if (axisSpecifier === constants.DIR_LEFT) {\n      applyY2Axis = false\n    }\n\n    if (axisSpecifier === constants.DIR_RIGHT) {\n      applyY1Axis = false\n    }\n\n    // If Max value is provided in options, Dont compute next possible tick.\n    yMax = getObject(this.options, 'yAxis.left.max')\n    if (this.options.yRange && applyY1Axis && !Number.isFinite(yMax)) {\n      tickValArr = this.yAxis.tickValues\n      // If tickValArr contains values\n      if (tickValArr.length > 1) {\n        // Find difference of last and last previous tick values of Y Axis\n        diffVal = tickValArr[0] - tickValArr[1]\n        // New range is increased by above difference\n        rangeVal = tickValArr[0] + diffVal\n\n        // Modify new max range for the graph\n        this.options.yRange[1] = rangeVal\n\n        // Update Y Axis with new domainScale\n        this.yAxis.modifyAxisProps({\n          domainScale: this.options.yRange\n        })\n      }\n    }\n\n    yMax = getObject(this.options, 'yAxis.right.max')\n    if (this.options.yRange2 && applyY2Axis && !Number.isFinite(yMax)) {\n      tickValArr = this.yAxis2.tickValues\n\n      if (tickValArr.length > 1) {\n        diffVal = tickValArr[0] - tickValArr[1]\n        rangeVal = tickValArr[0] + diffVal\n\n        this.options.yRange2[1] = rangeVal\n\n        // Update Y Axis with new domainScale\n        this.yAxis2.modifyAxisProps({\n          domainScale: this.options.yRange2\n        })\n      }\n    }\n\n    // Adjusts Y axis width based on max text length displayed\n    const reScaleAxis = {}\n    let requiredWidth = 0\n\n    if (this.options.yRange) {\n      reScaleAxis[constants.DIR_LEFT] = {}\n      reScaleAxis[constants.DIR_LEFT].class = '.vc-axis-left'\n      reScaleAxis[constants.DIR_LEFT].maxText = ''\n    }\n\n    if (this.options.yRange2) {\n      reScaleAxis[constants.DIR_RIGHT] = {}\n      reScaleAxis[constants.DIR_RIGHT].class = '.vc-axis-right'\n      reScaleAxis[constants.DIR_RIGHT].maxText = ''\n    }\n\n    // Creates dummy svg to add Max length tick values and check its required width in chart\n    const dummyG = this.svg.append('g')\n      .attr('class', 'vc-axis')\n\n    for (const axis in reScaleAxis) {\n      const ticksArr = this.container.select('svg ' + reScaleAxis[axis].class).selectAll('text')\n      ticksArr.each(function (i) {\n        const tickHtml = select(this).text() || ''\n        if (tickHtml.length > reScaleAxis[axis].maxText.length) {\n          reScaleAxis[axis].maxText = tickHtml\n        }\n      })\n\n\n      dummyG.selectAll('.dummyText')\n        .data([reScaleAxis[axis].maxText])\n        .enter()\n        .append('text')\n        .text(String)\n        .each(function (d, i) {\n          // Compute requiredWidth for the Max text\n          requiredWidth = this.getComputedTextLength()\n        })\n\n      // Update respective margin to fit in ticks text\n      this.margin[axis] = Math.round(requiredWidth) + constants.Y_AXIS_SPACE\n\n    }\n    dummyG.remove()\n\n    this.chartWidth = (this.chartFullSpace.width - this.margin.left - this.margin.right)\n    this.update()\n  }\n\n}\n","import ChartComponent from '@/charts/ChartComponent'\nimport {elementOffset, isFunction} from '@/utils'\n\nexport default class BasicTooltip extends ChartComponent {\n  constructor (opts) {\n    super()\n    this.opts = Object.assign({\n      visible: true\n    }, opts)\n\n    // Provide basic formatter to display hover data\n    if (!isFunction(this.opts.format)) {\n      this.opts.format = function (d) {\n        return `<span> ToolTip Text : </span><br/><span>${JSON.stringify(d)}</span>`\n      }\n    }\n  }\n\n  draw () {\n    this.toolTipDiv = this.opts && this.opts.chart.container\n      .append('div')\n      .attr('class', 'vc-tooltip-display ' + this.opts.className)\n  }\n\n  hover (x, y, displayData, excludeToolTipDiv) {\n    this.showHide(true)\n    // This will be called by series -- bar / pie\n    const box = elementOffset(this.toolTipDiv)\n    const rootPos = elementOffset(this.opts.chart.container)\n    let xpos = Math.round(x - rootPos.left)\n    let ypos = Math.round(y - rootPos.top)\n\n    if (!excludeToolTipDiv) {\n      // Consider toolTip offset for position\n      xpos = Math.round(xpos - (box.width / 2))\n      ypos = Math.round(ypos - (box.height / 2))\n    }\n\n\n    this.toolTipDiv\n      .style('left', xpos + 'px')\n      .style('top', ypos + 'px')\n      .style('display', 'inline-block')\n      .html(this.opts.format.call(this.opts.chart, displayData.data)) // Used format.call(), so that external fun can have access of chart Instance\n  }\n\n  showHide (showFlag) {\n    showFlag = !!showFlag\n    this.toolTipDiv && this.toolTipDiv.classed('vc-hidden', !showFlag)\n  }\n\n  remove () {\n    this.$toolTipDiv && this.$toolTipDiv.remove()\n    this.opts = null\n  }\n}\n"],"sourceRoot":""}